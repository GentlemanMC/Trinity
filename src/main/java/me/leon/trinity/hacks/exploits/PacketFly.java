package me.leon.trinity.hacks.exploits;

import me.leon.trinity.events.main.EventPacketRecieve;
import me.leon.trinity.events.main.MoveEvent;
import me.leon.trinity.events.main.SpoofEvent;
import me.leon.trinity.hacks.Category;
import me.leon.trinity.hacks.Module;
import me.leon.trinity.managers.SpoofingManager;
import me.leon.trinity.setting.rewrite.BooleanSetting;
import me.leon.trinity.setting.rewrite.ModeSetting;
import me.leon.trinity.setting.rewrite.SliderSetting;
import me.leon.trinity.utils.entity.MotionUtils;
import me.leon.trinity.utils.world.Timer;
import me.zero.alpine.fork.listener.EventHandler;
import me.zero.alpine.fork.listener.Listener;
import net.minecraft.network.play.client.CPacketConfirmTeleport;
import net.minecraft.network.play.client.CPacketPlayer;
import net.minecraft.network.play.server.SPacketPlayerPosLook;

import java.util.Random;

public class PacketFly extends Module {
	public static ModeSetting mode = new ModeSetting("Mode", "Up", "Down", "Preserve", "Up", "Bounds", "Switch");
	public static SliderSetting factor = new SliderSetting("Factor", 0.5, 1, 10, false);
	public static BooleanSetting noClip = new BooleanSetting("Phase", true);
	public static BooleanSetting update = new BooleanSetting("Update", true);
	public static BooleanSetting reset = new BooleanSetting("Reset", false);
	public static BooleanSetting antikick = new BooleanSetting("AntiKick", false, true);
	public static SliderSetting time = new SliderSetting("Timer", antikick, 0, 500, 2000, true);
	public static SliderSetting amount = new SliderSetting("Amount", antikick, 0, 10, 100, true);

	private final Random random = new Random();
	private final Timer timer = new Timer();

	private int lastTp = 0;
	private boolean first = true;

	public PacketFly() {
		super("PacketFly", "Use packets to fly", Category.EXPLOITS);
	}

	@EventHandler
	private final Listener<MoveEvent> eventMove = new Listener<>(event -> {
		if (nullCheck()) return;

		mc.player.setVelocity(0, 0, 0);

		if (noClip.getValue()) {
			mc.player.noClip = true;
		}

		MotionUtils.doStrafe(getSpeed());
		event.y = mc.player.motionY = getY();
		event.x = mc.player.motionX;
		event.z = mc.player.motionZ;
		mc.player.onGround = false;

		event.cancel();
	});

	@Override
	public String getHudInfo() {
		return mode.getValue();
	}

	@EventHandler
	private final Listener<SpoofEvent> listener0 = new Listener<>(event -> {
		int yOff = 0;
		int xOff = 0;
		int zOff = 0;

		switch (mode.getValue()) {
			case "Up": {
				yOff = 1337;
				break;
			}
			case "Down": {
				yOff = -1337;
				break;
			}
			case "Preserve": {
				xOff = random.nextInt(100000);
				zOff = random.nextInt(100000);
				yOff = (int) (mc.player.posY + mc.player.motionY);
				break;
			}
			case "Bounds": {
				yOff = 1;
				break;
			}
			case "Switch": {
				yOff = (mc.player.ticksExisted % 2 == 1 ? 1000 : -1000);
				break;
			}
		}

		mc.player.onGround = false;

		double x = mc.player.posX + mc.player.motionX;
		double y = mc.player.posY + mc.player.motionY;
		double z = mc.player.posZ + mc.player.motionZ;

		mc.player.connection.sendPacket(new CPacketPlayer.Position(x, y, z, first));
		mc.player.connection.sendPacket(new CPacketPlayer.Position(x + xOff, yOff, z + zOff, first));

		++this.lastTp;
		mc.player.connection.sendPacket(new CPacketConfirmTeleport(this.lastTp));

		if(first) {
			first = false;
		}
	});

	@EventHandler
	public Listener<EventPacketRecieve> onPacket = new Listener<>(event -> {
		if (event.getPacket() instanceof SPacketPlayerPosLook && mc.currentScreen == null) {
			final SPacketPlayerPosLook packet = (SPacketPlayerPosLook)event.getPacket();
			mc.player.connection.sendPacket(new CPacketConfirmTeleport(packet.getTeleportId()));
			mc.player.connection.sendPacket(new CPacketPlayer.PositionRotation(packet.getX(), packet.getY(), packet.getZ(), packet.getYaw(), packet.getPitch(), false));
			mc.player.setPosition(packet.getX(), packet.getY(), packet.getZ());

			if(update.getValue()) {
				this.lastTp = packet.teleportId;
				mc.player.onGround = false;
			}

			event.cancel();
		}
	});

	@Override
	public void onUpdate() {
		if (nullCheck()) {
			this.setEnabled(false);
		}
	}

	private boolean checkHitBoxes() {
		return !mc.world.getCollisionBoxes(mc.player, mc.player.getEntityBoundingBox().expand(-0.0625, -0.0625, -0.0625)).isEmpty();
	}

	private float getY() {
		if(antikick.getValue()) {
			if(timer.hasPassAndReset((int) time.getValue())) {
				return (float) -(amount.getValue() / 100f);
			}
		}
		if (mc.gameSettings.keyBindJump.isKeyDown() && mc.gameSettings.keyBindSneak.isKeyDown()) {
			return 0f;
		}
		if (mc.gameSettings.keyBindJump.isKeyDown()) {
			return getSpeed();
		}
		if (mc.gameSettings.keyBindSneak.isKeyDown()) {
			return -getSpeed();
		}
		return 0.0f;
	}

	@Override
	public void onDisable() {
		if(reset.getValue()) this.lastTp = 0;
		this.first = true;
		SpoofingManager.cancel = false;
	}

	@Override
	public void onEnable() {
		if(reset.getValue()) this.lastTp = 0;
		this.first = true;
		SpoofingManager.cancel = true;
	}

	private float getSpeed() {
		return (float) ((checkHitBoxes() ? 0.036 : 0.062) * factor.getValue());
	}

	@Override
	public boolean shouldSave() {
		return false;
	}
}
