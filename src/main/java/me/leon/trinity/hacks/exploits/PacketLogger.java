package me.leon.trinity.hacks.exploits;

import me.leon.trinity.events.main.EventPacketRecieve;
import me.leon.trinity.events.main.EventPacketSend;
import me.leon.trinity.hacks.Category;
import me.leon.trinity.hacks.Module;
import me.leon.trinity.setting.rewrite.BooleanSetting;
import me.leon.trinity.setting.rewrite.SliderSetting;
import me.leon.trinity.utils.misc.MessageBus;
import me.zero.alpine.fork.listener.EventHandler;
import me.zero.alpine.fork.listener.Listener;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.CPacketConfirmTeleport;
import net.minecraft.network.play.client.CPacketPlayer;
import net.minecraft.network.play.server.SPacketPlayerPosLook;

import java.math.BigDecimal;
import java.math.RoundingMode;

public class PacketLogger extends Module {
    public static final BooleanSetting timer = new BooleanSetting("Timer", true);
    public static final SliderSetting timerAmount = new SliderSetting("TimerAmount", 0, 60, 100, true);

    public static final BooleanSetting in = new BooleanSetting("In", true, true);

    public static final BooleanSetting out = new BooleanSetting("Out", true, true);
    public static final BooleanSetting cposition = new BooleanSetting("CPacketPlayerPosition", out, true);
    public static final BooleanSetting cconfirm = new BooleanSetting("CPacketConfirmTeleport", out, true);

    @Override
    public String getHudInfo() {
        return String.valueOf(packets);
    }

    private int packets;
    private long time = 0;

    public PacketLogger() {
        super("PacketLogger", "Logs packets", Category.EXPLOITS);
    }

    @EventHandler
    private final Listener<EventPacketSend> onPacketSend = new Listener<>(event -> {
        if(!out.getValue()) return;

        final Packet<?> event_p = event.getPacket();
        if(event_p instanceof CPacketConfirmTeleport && cconfirm.getValue()) {
            final CPacketConfirmTeleport packet = (CPacketConfirmTeleport) event_p;
            MessageBus.sendClientMessage("Confirm: [ " + packet.getTeleportId() + " ]", true);
            packets++;
        } else
        if(event_p instanceof CPacketPlayer && cposition.getValue()) {
            final CPacketPlayer packet = (CPacketPlayer) event_p;
            if(packet.moving) {
                final double x = roundToPlace(packet.x, 2);
                final double y = roundToPlace(packet.y, 2);
                final double z = roundToPlace(packet.z, 2);
                final String message = String.format("Pos: [%s, %s, %s] [ %b ]", x, y, z, packet.onGround);
                MessageBus.sendClientMessage(message, true);
                packets++;
            }
        }
        if(packets == (int) timerAmount.getValue()) {
            MessageBus.sendClientMessage(packets + " packets has been sent. " + (System.currentTimeMillis() - time) + " millis has passed.", true);
            time = System.currentTimeMillis();
            packets = 0;
        }
    });

    @EventHandler
    private final Listener<EventPacketRecieve> onPacketReceive = new Listener<>(event -> {
        if(!in.getValue()) return;

        final Packet<?> event_p = event.getPacket();
        if(event_p instanceof SPacketPlayerPosLook && cconfirm.getValue()) {
            final SPacketPlayerPosLook packet = (SPacketPlayerPosLook) event_p;
            final double x = roundToPlace(packet.x, 2);
            final double y = roundToPlace(packet.y, 2);
            final double z = roundToPlace(packet.z, 2);
            final String message = String.format("[S] Pos: [%s, %s, %s]", x, y, z);
            MessageBus.sendClientMessage("[S] Confirm: [ " + packet.getTeleportId() + " ]", true);
            MessageBus.sendClientMessage(message, true);
        }
    });

    private double roundToPlace(double value, int places) {
        if (places < 0) {
            throw new IllegalArgumentException();
        }
        BigDecimal bd = new BigDecimal(value);
        bd = bd.setScale(places, RoundingMode.HALF_UP);
        return bd.doubleValue();
    }
}
